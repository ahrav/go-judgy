package activity

import (
	"context"
	"fmt"
	"sync/atomic"

	"github.com/google/uuid"

	"github.com/ahrav/go-judgy/internal/domain"
	"github.com/ahrav/go-judgy/internal/llm/transport"
)

// mockLLMClient provides controllable LLM client behavior for testing activities.
// It supports configurable error conditions, call tracking, and deterministic
// responses for validating activity error handling and retry behavior.
type mockLLMClient struct {
	// Control behavior
	generateReturnsError bool
	scoreReturnsError    bool
	generateError        error
	scoreError           error

	// Track calls (atomic for thread safety)
	generateCalls int64
	scoreCalls    int64
}

// Generate simulates LLM answer generation with controllable error behavior.
// Returns configurable errors or minimal valid responses for testing activity logic.
func (m *mockLLMClient) Generate(
	ctx context.Context, input domain.GenerateAnswersInput,
) (*domain.GenerateAnswersOutput, error) {
	atomic.AddInt64(&m.generateCalls, 1)

	if m.generateReturnsError {
		if m.generateError != nil {
			return nil, m.generateError
		}
		// Return the expected "not implemented" error for backward compatibility
		// This will be wrapped by the activity in a temporal.ApplicationError
		return nil, fmt.Errorf("GenerateAnswers not implemented: %w", ErrNotImplemented)
	}

	// CRITICAL: Generate proper idempotency key just like real client
	// Use deterministic tenant ID for testing based on input to ensure same input = same key
	tenantID := "test-tenant-deterministic"
	req := &transport.Request{
		Operation:   transport.OpGeneration,
		Provider:    input.Config.Provider,
		Model:       input.Config.Model,
		TenantID:    tenantID,
		Question:    input.Question,
		MaxTokens:   input.Config.MaxAnswerTokens,
		Temperature: input.Config.Temperature,
	}

	canonicalKey, err := transport.GenerateIdemKey(req)
	if err != nil {
		return nil, fmt.Errorf("failed to generate idem key: %w", err)
	}

	// Return a valid output with minimal data and content in metadata
	return &domain.GenerateAnswersOutput{
		Answers: []domain.Answer{
			{
				ID: uuid.New().String(), // Proper UUID
				AnswerProvenance: domain.AnswerProvenance{
					Provider: "mock",
					Model:    "mock-model",
				},
				ContentRef: domain.ArtifactRef{
					// Leave empty so storeAnswerContent will handle storage
					Key:  "",
					Kind: domain.ArtifactAnswer,
				},
				Metadata: map[string]any{
					"content": "This is a test answer generated by the mock LLM client.",
				},
			},
		},
		TokensUsed:    100,
		CallsMade:     1,
		CostCents:     domain.Cents(25),      // 25 cents
		ClientIdemKey: canonicalKey.String(), // ‚Üê RETURN THE KEY!
	}, nil
}

// Score simulates LLM answer scoring with controllable error behavior.
// Returns configurable errors or minimal valid scores for testing activity logic.
func (m *mockLLMClient) Score(_ context.Context, in domain.ScoreAnswersInput) (*domain.ScoreAnswersOutput, error) {
	atomic.AddInt64(&m.scoreCalls, 1)

	if m.scoreReturnsError {
		if m.scoreError != nil {
			return nil, m.scoreError
		}
		// Return the expected "not implemented" error for backward compatibility
		// This will be wrapped by the activity in a temporal.ApplicationError
		return nil, fmt.Errorf("ScoreAnswers not implemented: %w", ErrNotImplemented)
	}

	// Return a valid output with minimal data
	scores := make([]domain.Score, 0, len(in.Answers))
	for _, answer := range in.Answers {
		scores = append(scores, domain.Score{
			ID:         fmt.Sprintf("score-%s", answer.ID),
			AnswerID:   answer.ID,
			Value:      75,
			Confidence: 0.85,
			ScoreValidity: domain.ScoreValidity{
				Valid: true,
			},
		})
	}

	return &domain.ScoreAnswersOutput{
		Scores:     scores,
		TokensUsed: 50,
		CallsMade:  1,
	}, nil
}

// newMockLLMClient creates a mock client configured to return "not implemented" errors.
// This supports testing stub activity behavior during development phases.
func newMockLLMClient() *mockLLMClient {
	return &mockLLMClient{
		generateReturnsError: true,
		scoreReturnsError:    true,
	}
}
